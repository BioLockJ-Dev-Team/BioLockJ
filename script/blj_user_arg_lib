#!/bin/bash
###################################################################
##                                                               ##
##  This script contains common functions used in                ##
##  BioLockJ scripts to interpret user input.                    ##
##                                                               ##
###################################################################

. ${BLJ_SCRIPT}/blj_functions

# example: take_standard_biolockj_args "$@"
take_standard_biolockj_args(){
	set_arg_names
	init_defaults
	split_main_arg_from_options "$@"
	[ ${#options[@]} -gt 0 ] && parse_options "${options[@]}"
	[ ${#BIOLOCKJ_TEST_MODE} -gt 0 ] && display_arg_vals
}

set_arg_names(){
	GUI_ARG="gui"
	PASSWORD_ARG="password"
	CONFIG_ARG="config-override"
	RESTART_ARG="restart"
	AWS_ARG="aws"
	DOCKER_ARG="docker"
	FG_ARG="foreground"
	EXT_MODS_ARG="external-modules"
	BLJ_ARG="blj"
	BLJ_SUP_ARG="blj_sup"
	# not shown in user documentation
	FROM_GUI_ARG="blj_gui" #This flag indicates that a pipeline was launched by the GUI.
}

init_defaults(){
	# Order does not matter for $longArgName or $takeShortArg, but it is easier to read if they match
	# Order MATTERS for $shortArgName and $parameters ---they must match whatever order is in $longArgName.
	longArgName=( $GUI_ARG $PASSWORD_ARG $CONFIG_ARG $RESTART_ARG $AWS_ARG $DOCKER_ARG $FG_ARG $EXT_MODS_ARG $BLJ_ARG $BLJ_SUP_ARG $FROM_GUI_ARG )
	takeShortArg=($GUI_ARG $PASSWORD_ARG $CONFIG_ARG $RESTART_ARG $AWS_ARG $DOCKER_ARG $FG_ARG help version)
	shortArgName=()
	parameters=()
	mustTakeValue=($PASSWORD_ARG $CONFIG_ARG)
	canTakeValue=($mustTakeValue $BLJ_SUP_ARG)
	for i in ${!longArgName[@]}; do
		longName=${longArgName[ $i ]}
		if containsElement $longName ${takeShortArg[@]}
			then shortArgName[ $i ]=${longName:0:1}
			else shortArgName[ $i ]=$longName # a place holder
		fi 
		parameters[ $i ]="default"
		i=$((i+1))
	done
	argsFromUser=() # distinguish between the default, and the user supplying "default" as the value
}

# get the last argument, and call it mainArg
# all preceding arguments are options
split_main_arg_from_options(){
	local args=( "$@" )	
	numArgs=${#args[@]}
	mainArg=${args[$numArgs-1]}
	options=()
	if [ $numArgs -gt 1 ]; then
		for i in $(seq 0 $((${#args[@]} - 2)) ); do
			options[ $i ]=${args[ $i ]}
		done
	fi
	if [ ${mainArg:0:1} == "-" ]; then
		mainArg=""
		local i=${#options[@]}
		options[ $i ]=${args[ $i ]}
	fi
}


# call using: parse_options $options
# assumes that the following variables exist: 
#   order within these three should match: longArgName, shortArgName, parameters
#   order of these does not matter:    mustTakeValue, canTakeValue
parse_options(){
	argName=""
	# iterate over all args except the the last one; that one is handled as "mainArg"
	for arg in "$@" ; do
		# if arg starts with -, we assume its an an argument name
		if [ ${arg:0:1} == "-" ]; then
			[ ${#argName} -gt 0 ] && containsElement $argName ${mustTakeValue[@]} && exit_with_message "error: the value of argument [ $argName ] should not begin with \"-\", found [ $arg ]."
			argName=""
			#  if arg starts with --, we assume it is a long-form argument name or flag
			if [ ${arg:0:2} == "--" ]; then
				arg=${arg#--}
				apply_arg $arg	
			else # only single -, we assume it is a short-form argument
				arg=${arg#-}
				#process each letter in arg, so multiple short form args can be stacked behind a single -
				for i in $(seq 0 $((${#arg} - 1)) ); do
					letter=${arg:$i:1}
					if index=$( index_of $letter ${shortArgName[@]})
						then apply_arg ${longArgName[${index}]}
						else exit_with_message "error: unrecognized short-form argument [ -$letter ]."
					fi
				done
			fi		
		# if arg starts with no dashes, we assume it must be the value for $argName
		else
			[ ${#argName} -eq 0 ] && exit_with_message "error: unnamed value [ $arg ]"
			if index=$( index_of $argName "${longArgName[@]}" )
				then parameters[ $index ]=${arg} && argName=""
				else exit_with_message "error: unrecognized argument name [ $argName ]"
			fi
		fi		
	done
	[ ${#argName} -gt 0 ] && containsElement $argName ${mustTakeValue[@]} && exit_with_message "error: argument [ $argName ] must take a value."
}

# Determine if an argument takes a value; if so, store the name and await the value
# otherwise the argument is a flag, set that parameter to true
# param1: the long-form argument name
apply_arg(){
	argsFromUser=($argsFromUser $1)
	containsElement $1 "${canTakeValue[@]}" && argName=$1
	set_flag_to_true $1
}

# Set a parameter value to true
# param1: name of flag to set
set_flag_to_true(){
	index=$( index_of $1 ${longArgName[@]} ) && parameters[${index}]="true"
	[ $index -eq "-1" ] && exit_with_message "error: unrecognized argument [ $1 ]."
}

# sets variables configFile and/or restartDir
assign_main_arg(){
	if ifArgUsed $RESTART_ARG ; then
		restartDir=$mainArg
		[ ${#BIOLOCKJ_TEST_MODE} -gt 0 ] && echo "Using $restartDir as the pipeline to restart."
		ifArgUsed $CONFIG_ARG && configFile=configoverride && echo "Updating pipeline with config file $configFile."
	else
		configFile=$mainArg
		[ ${#BIOLOCKJ_TEST_MODE} -gt 0 ] && echo "Using $configFile as the config file."
	fi
}

# Only used when BIOLOCKJ_TEST_MODE is set.
display_arg_vals(){
	for ARG in ${longArgName[@]} ; do
		if ifArgUsed $ARG ; then
			argVal=$(get_arg_value $ARG)
			echo "$ARG = $argVal"
		fi
	done 
}



### These functions are used by the main scripts to querry user args

# Use this to set a value to true or false; remember these are strings, not logic values
# param 1: argument name (from longArgName array)
trueIfArgUsed(){
	if containsElement $1 ${argsFromUser[@]}
		then echo "true"
		else echo "false"
	fi
}

# Use this to control logic flow
# ex: ifArgUsed $BLJ_ARG && blj=$BLJ || blj=""
# param 1: argument name (from longArgName array)
ifArgUsed(){
	local tmp=$(trueIfArgUsed $1)
	[ $tmp == "true" ] && return 0
	[ $tmp == "false" ] && return 1
}

# Return the value that was passed after a given arg
# If the arg is not in the list of arg names, then return status 1 (ie, unsuccessful)
# param 1 - the arg name
get_arg_value(){
	index=$( index_of $1 ${longArgName[@]} ) && echo ${parameters[$index]} || return 1
}

# return the index of $1 in the array (remaining args)--IFF it is in the array
index_of(){
	local array=( "$@" )
	for arrayIndex in $(seq 1 ${#array[@]}); do
		if [ "${array[$arrayIndex]}" == "$1" ]; then
			echo $(( $arrayIndex - 1 ))
			return 0
		fi
	done
	echo "-1"
	return 1
}


### These functions are used to give info to the user

# Display BioLockJ release version
display_version() {
	[ -f "${BLJ}/.version" ] && cat "${BLJ}/.version" && return
	echo "Missing ${BLJ}/.version"
}

# Show the help menu
display_help() {
	set_arg_names
	init_defaults
	addSpace(){
		if [ ${#BIOLOCKJ_TEST_MODE} -gt 0 ]; then
			local allargs=(${longArgName[@]} help version)
			if ! containsElement $1 ${allargs[@]} ; then 
				echo "$1 may not be supported!"
			fi
		fi
		if containsElement $1 ${takeShortArg[@]}
			then addSpaceWithShort "${@}"
			else addSpaceNoShortArg "${@}"
		fi
	}
	addSpaceWithShort(){ 
		printf '%-1s %-3s %-25s %-10s\n' "" "-${1:0:1}" "--$1" "$2"
	}
	addSpaceNoShortArg(){ 
		printf '%-1s %-3s %-25s %-10s\n' "" "" "--$1" "$2"
	}
	continueDescriptoin(){
		printf '%-1s %-3s %-25s %-10s\n' "" "" "" "$1"
	}
	echo ""
	echo "BioLockJ $(display_version) - UNCC Fodor Lab July 2018" 
    echo 'Usage:'
    printf '%-1s %-3s' "" "biolockj [options] <config|pipeline>" && echo ""
    echo ""
    echo 'Options:'
    addSpace "version"       "Show version"
    addSpace "help"          "Show help menu"
    addSpace "restart"       "Resume an existing pipeline"
    addSpace "$CONFIG_ARG <file>" "New config file (if restarting a pipeline)"
    addSpace "$PASSWORD_ARG <password>" "Encrypt password"
    addSpace "$DOCKER_ARG"   "Run in docker"
    addSpace "$AWS_ARG"      "Run on aws"
    addSpace "$GUI_ARG"      "Start the BioLockJ GUI"
    addSpace "$FG_ARG"       "Run the java process in the foreground without nohup"
    addSpace "$EXT_MODS_ARG <dir>" "Directory with compiled java code giving additional modules"
    addSpace "$BLJ_ARG"      "Map \$BLJ folder into the docker container;"
    continueDescriptoin      "this replaces BioLockJ packaged in a docker container with the local copy."
    addSpace "$BLJ_SUP_ARG <dir>" "Map <dir> folder into the docker container as /app/blj_support,"
    continueDescriptoin      "if <dir> is not given, variable \$BLJ_SUP is used"
    echo ""
}

